#!/bin/sh

${DEBUG:="false"} && set -x
prefix=@prefix@
exec_prefix=@exec_prefix@
PATH=@bindir@:@sbindir@:$PATH
export PATH

PROTO=sockets
DBDIR=/tmp/$USER
DBSIZE=$((256 * 1024 * 1024))
LOG_DIR=
IFACE=default
VNAME=default
CHFSD="env LD_LIBRARY_PATH=$LD_LIBRARY_PATH $(which chfsd)"
DEVDAX=false
NO_SERVER=true
SUDO=
NUM_SERVS=32

program=$(basename $0)

err() {
	[ "X$*" = X ] || echo >&2 $program: $*
	exit 1
}

usage() {
	[ "X$*" = X ] || echo >&2 $program: $*
	echo >&2 "usage: $program [-h hostfile] [-c scratch_dir] [-D] [-m mount_point]"
	echo >&2 "		[-p proto] [-s db_size] [-N vname] [-I interface]"
	echo >&2 "		[-C socket#] [-L log_dir] [-A] [-O options]"
	echo >&2 "		[-n #servers for CHFS_SERVER]"
	echo >&2 "		start | stop | status | kill | clean"
	exit 1
}

while [ $# -gt 0 ]; do
	case $1 in
	    start|stop|status|kill|clean) mode=$1 ;;
	    -A) NO_SERVER=false ;;
	    -c) shift; DBDIR=$1 ;;
	    -C) shift; CPUSOCKET=$1 ;;
	    -D) DEVDAX=true ;;
	    -h) shift; HOSTFILE=$1 ;;
	    -I) shift; IFACE=$1 ;;
	    -L) shift; LOG_DIR=$1 ;;
	    -m) shift; MDIR=$1 ;;
	    -n) shift; NUM_SERVS=$1 ;;
	    -N) shift; VNAME=$1 ;;
	    -O) shift; OPTIONS="$1" ;;
	    -p) shift; PROTO=$1 ;;
	    -s) shift; DBSIZE=$1 ;;
	    -*) echo "unknown option: $1"
		usage ;;
	    *) usage ;;
	esac
	[ $# -eq 0 ] && usage
	shift
done

[ "X$mode" = X ] && usage
[ "X$HOSTFILE" != X ] &&
	[ ! -f $HOSTFILE ] && usage $HOSTFILE: no such file
if [ "X$LOG_DIR" != X ]; then
	[ -d "$LOG_DIR" ] || mkdir -p "$LOG_DIR"
	[ -d "$LOG_DIR" ] || err $LOG_DIR: no such directory
fi

[ "$mode" = kill ] && PKILL_FLAG=-9 || PKILL_FLAG=
if $DEVDAX; then
	[ -w $DBDIR ] || SUDO=sudo
else
	DBDIR=$DBDIR/$IFACE-$VNAME
fi
[ "X$HOSTFILE" = X ] && HOSTS=localhost ||
	HOSTS="$(sed -e 's/#.*//' -e '/^[ 	]*$/d' $HOSTFILE | awk '{ print $1 }')"
[ "X$CPUSOCKET" = X ] && NUMACTL= || NUMACTL="numactl -N $CPUSOCKET"
if ! $NO_SERVER; then
	[ X"$CHFS_SERVER" = X ] && err CHFS_SERVER not specified
fi

CHFS_OPTIONS="-p $PROTO -s $DBSIZE $OPTIONS"
SERVER_INFO_FILE=/tmp/server-info-file-$USER

MAX_JOBS=8

stop_chfs() {
	$SUDO rm -f $SERVER_INFO_FILE

	if [ "X$HOSTS" = Xlocalhost ]; then
		$SUDO pkill $PKILL_FLAG chfsd
		[ "$mode" = kill ] && pkill $PKILL_FLAG chfuse
		if [ X"$MDIR" != X ]; then
			fusermount -u "$MDIR"
		fi
		HOSTS=
	fi
	p=0
	for host in $HOSTS
	do
		ssh $host $SUDO pkill $PKILL_FLAG chfsd &
		[ "$mode" = kill ] && ssh $host pkill $PKILL_FLAG chfuse &
		if [ X"$MDIR" != X ]; then
			ssh $host fusermount -u "$MDIR" &
		fi

		p=$((p + 1))
		if [ $p -ge $MAX_JOBS ]; then
			p=0
			wait
		fi
	done
	wait
}

clean_chfs() {
	[ -w / ] && err $mode: root not allowed

	if [ "X$HOSTS" = Xlocalhost ]; then
		rm -rf $DBDIR/*
		HOSTS=
	fi
	p=0
	for host in $HOSTS
	do
		ssh $host rm -rf $DBDIR/\* &

		p=$((p + 1))
		if [ $p -ge $MAX_JOBS ]; then
			p=0
			wait
		fi
	done
	wait
}

status_chfs() {
	if ! $NO_SERVER; then
		chlist
	elif [ -s $SERVER_INFO_FILE ]; then
		chlist -s $(cat $SERVER_INFO_FILE)
	else
		echo >&2 no server info file
	fi

	if [ "X$HOSTS" = Xlocalhost ]; then
		echo $(hostname -f)
		ps -ef | grep chfsd | egrep -v grep
		ps -ef | grep chfuse | egrep -v grep
		HOSTS=
	fi
	for host in $HOSTS
	do
		echo $host
		ssh $host "ps -ef | grep chfsd | egrep -v grep"
		ssh $host "ps -ef | grep chfuse | egrep -v grep"
	done
}

remove_file() {
	h=$1
	f=$2

	if [ "X$h" = Xlocalhost ]; then
		$SUDO rm -f $f
	else
		ssh $h $SUDO rm -f $f
	fi
}

does_exist() {
	h=$1
	f=$2

	if [ "X$h" = Xlocalhost ]; then
		test -s $f
	else
		ssh $h test -s $f
	fi
}

cat_file() {
	h=$1
	f=$2

	if [ "X$h" = Xlocalhost ]; then
		cat $f
	else
		ssh $h cat $f
	fi
}

start_chfs() {
nservers=0
if ! $NO_SERVER; then
	SERVERS="$(chlist | awk '{ print $1 }')"
	[ "X$SERVERS" = X ] && err chlist: no server
	set $SERVERS
	MAX_JOBS=$#
	nservers=$#
fi
p=0
for host in $HOSTS
do
	if $NO_SERVER; then
		remove_file $host $SERVER_INFO_FILE
		set -- "-S $SERVER_INFO_FILE"
		MAX_JOBS=1
	fi

	[ $VNAME = default ] && NOPT= || NOPT="-n $VNAME"
	[ $IFACE = default ] && HOPT= || HOPT="-h $IFACE"
	COPT="-c $DBDIR"
	[ "X$LOG_DIR" = X ] && LOPT= || LOPT="-l $LOG_DIR/$host-$IFACE-$VNAME"
	if [ "X$host" = Xlocalhost ]; then
		$SUDO $NUMACTL $CHFSD $CHFS_OPTIONS $COPT $LOPT $HOPT $NOPT "$1"
	else
		[ "X$LOG_DIR" != X ] && ssh $host $SUDO mkdir -p $LOG_DIR
		ssh $host LD_LIBRARY_PATH=\"$LD_LIBRARY_PATH\" PATH=\"$PATH\" $SUDO $NUMACTL $CHFSD $CHFS_OPTIONS $COPT $LOPT $HOPT $NOPT \"$1\"
	fi
	[ $? -eq 0 ] || continue
	nservers=$((nservers + 1))

	if $NO_SERVER; then
		timeout=10
		while [ $timeout -gt 0 ]; do
			if does_exist $host $SERVER_INFO_FILE; then
				break
			fi
			sleep 1
			timeout=$((timeout - 1))
		done
		[ $timeout -eq 0 ] && err $CHFSD: timeout

		SERVER=`cat_file $host $SERVER_INFO_FILE`
		[ X"$SERVER" = X ] && err $CHFSD: no server info
		NO_SERVER=false
		CHFS_SERVER="$SERVER"; export CHFS_SERVER
	fi

	shift
	p=$((p + 1))
	if [ $p -ge $MAX_JOBS ]; then
		p=0
		set $(chlist | awk '{ print $1 }')
		MAX_JOBS=$#
	fi
done
if $NO_SERVER; then err no server executed; fi
timeout=10
while [ $timeout -gt 0 -a $(chlist | wc -l) -lt $nservers ]; do
	timeout=$((timeout - 1))
	sleep 1;
done
echo "CHFS_SERVER=\"$(chlist -c -n $NUM_SERVS)\"; export CHFS_SERVER;"
CHFS_SERVER="$(chlist -c -n $NUM_SERVS)"; export CHFS_SERVER
if [ X"$MDIR" != X ]; then
	if [ $(chlist | wc -l) -lt $nservers ]; then
		echo >&2 "$program: timeout, $(chlist | wc -l) of $nservers servers are running.  you may need chmkdir $MDIR manually"
	fi
	chmkdir "$MDIR" > /dev/null 2>&1 || :

	if [ "X$HOSTS" = Xlocalhost ]; then
		mkdir -p "$MDIR"
		chfuse -o direct_io,modules=subdir,subdir="$MDIR" "$MDIR"
		HOSTS=
	fi
	for host in $HOSTS
	do
		ssh $host mkdir -p "$MDIR"
		ssh $host LD_LIBRARY_PATH=\"$LD_LIBRARY_PATH\" PATH=\"$PATH\" CHFS_SERVER=\"$CHFS_SERVER\" CHFS_LOG_PRIORITY=$CHFS_LOG_PRIORITY CHFS_CHUNK_SIZE=$CHFS_CHUNK_SIZE CHFS_RDMA_THRESH=$CHFS_RDMA_THRESH CHFS_RPC_TIMEOUT_MSEC=$CHFS_RPC_TIMEOUT_MSEC CHFS_NODE_LIST_CACHE_TIMEOUT=$CHFS_NODE_LIST_CACHE_TIMEOUT chfuse -o direct_io,modules=subdir,subdir="$MDIR" "$MDIR"
	done
fi
}

case $mode in
start)
	start_chfs ;;
stop|kill)
	stop_chfs ;;
status)
	status_chfs ;;
clean)
	clean_chfs ;;
*)
	usage ;;
esac

exit 0
